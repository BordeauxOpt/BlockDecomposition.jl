### DRAFTS

function toArray(a)
  if isa(a, Integer)
    return [a]
  end
  if isa(a, Tuple) || isa(a, Array) || isa(a, Pair)
    arr = Vector{Int}()
    for i in a
      arr = vcat(arr, toArray(i))
    end
    return arr
  end
  error("Object not supported : $a of type $(typeof(a)). You can only use Int, Array, Pair, and Tuple.")
end

function createMultiIndex(array_mid::Vector{Cint}, array::Vector{Int})
  length_array = length(array)
  length_array_mid = length(array_mid)
  (length(array) > 8) && error("BlockJuMP does not support multi-index with more than 8 indices.")
  for i in 1:length_array_mid
    if i <= length_array
      array_mid[i] = array[i]
    else
      array_mid[i] = -1
    end
  end
end

function fromIndexToMultiIndexArray(id)
  array_mid = fill(Cint(-1), 8)
  createMultiIndex(array_mid, toArray(id))
  return array_mid
end

function isa_jumpcontnr(a)
  typ = string(typeof(a))
  iscontnr = (match(r"^JuMP.JuMPArray", typ) !== nothing)
  iscontnr |= (match(r"^JuMP.JuMPArray", typ) !== nothing)
  return iscontnr
end

function get_bid_bgid_vcid(m::JuMP.Model, index)
  nbindices = length(index)
  nb_block_indices = m.ext[:BlockIdentification].nb_block_indices
  (nb_block_indices > nbindices) &&
    error("Less indices than nb_block_indices.")
  # Is there block-identification ?
  if nb_block_indices > 0
    b_id = index[1:nb_block_indices]
    bg_id = m.ext[:BlockIdentification].block_group_func(b_id)
  else # It's a MIP
    b_id = index
    bg_id = [-1]
  end
  # Getting variable or cstr index
  if nb_block_indices < nbindices
    vc_id = index[(nb_block_indices + 1):nbindices]
  else
    vc_id = [0]
  end
  (b_id, bg_id, vc_id)
end

function add_bgmid_to_bid_dict(m::JuMP.Model, dict, affected, varcstrcontnr)
  for index in keys(varcstrcontnr)
    (bid, bgid, vcid) = get_bid_bgid_vcid(m, index)
    if haskey(affected, bid)
      continue
    end
    bgmid = fromIndexToMultiIndexArray(bgid)
    if !haskey(dict, bgmid)
      dict[bgmid] = Vector{Any}()
    end
    push!(dict[bgmid], bid)
    affected[bid] = 1
  end
end

# Creates a dic to get the fibre of each block group index
function create_bgid_to_bid_dict(m::JuMP.Model)
  if haskey(m.ext, :bgmidToBid)
    return
  end
  m.ext[:bgmidToBid] = Dict{Vector{Cint}, Vector{Any}}()
  af = Dict{Any, Integer}()
  for var in m.ext[:VarNames]
    isa_jumpcontnr(var.second) && add_bgmid_to_bid_dict(m, m.ext[:bgmidToBid], af, var.second)
  end
  # for cstr in m.ext[:ConstrNames]
  #   isa_jumpcontnr(cstr.second) && add_bgmid_to_bid_dict(m, m.ext[:bgmidToBid], af, cstr.second)
  # end
end

#########################################################

macro generatemodelhandlers(m, args...)
    code = :()
    for arg in args
        tmp = "$arg"
        exp = :( _$arg = getvariable($m, Symbol($tmp) ) )
        @show exp
        code = quote
            $code
            $exp
        end
    end
    esc(code)
end


#############################################################################
immutable VarDescription
  name
  index
  col
end

function SubModel(parent::JuMP.Model, bgid, solver)
  tic()
  create_bgid_to_bid_dict(parent)
  println("\e[42m bdig to bid dict")
  toc()
  println("\e[00m")

  child = Model(solver = solver)
  @objective(child, Min, 0)

  bgmid = fromIndexToMultiIndexArray(bgid)
  if !haskey(parent.ext[:bgmidToBid], bgmid)
    return child
  end

  bids = parent.ext[:bgmidToBid][bgmid]
  nbblockindices = parent.ext[:BlockIdentification].nb_block_indices
  vardict = Dict{Integer, VarDescription}()

  submodel_create_vars(parent, child, bgmid, bids, nbblockindices, vardict)
  submodel_create_cstrs(parent, child, bgmid, bids, nbblockindices, vardict)
  return child
end

function isa_array(jumpcontnr)
  return isa(jumpcontnr, Array)
end

function isa_jumparray(jumpcontnr)
  return isa(jumpcontnr, JuMP.JuMPArray)
end

function isa_jumpdict(jumpcontnr)
  return isa(jumpcontnr, JuMP.JuMPDict)
end

function submodel_create_vars(parent, child, bgmid, bids, nbblockindices, vardict)
  for vars in parent.varDict
    isa_jumparray(vars.second) && submodel_create_vars_from_jumparray(parent, child, vars.first, vars.second, bids, nbblockindices, bgmid, vardict)
  end
end

function submodel_create_cstrs(parent, child, bgmid, bids, nbblockindices, vardict)
 for cstrs in parent.conDict
   isa_jumpcontnr(cstrs.second) && submodel_create_cstrs_from_jumparray(parent, child, cstrs.first, cstrs.second, bids, nbblockindices, bgmid, vardict)
 end
end

function var_lb_ub(var_declaration, lb, ub, cat)
  var_dec = var_declaration
  if cat == :Cont || cat == :Int
    if ub != +Inf
      var_dec = "$var_dec <= $ub"
    end
    if lb != -Inf
      var_dec = "$lb <= $var_dec"
    end
  elseif cat == :Bin
    if ub == 0
      var_dec = "$var_dec <= $ub"
    end
    if lb == 1
      var_dec = "$lb <= $var_dec"
    end
  end
  return var_dec
end

function cstr_lb_ub(cstr_declaration, lb, ub)
  cstr_dec = cstr_declaration
  if ub != +Inf
    cstr_dec = "$cstr_dec <= $lb"
  end
  if lb != +Inf
    cstr_dec = "$ub <= $cstr_dec"
  end
  return cstr_dec
end

function name_cont(name_declaration, sets, letter_code, opened_bracket, add_coma)
  name_dec = name_declaration
  for ids in sets # Creates index
    letter = string(Char(letter_code))
    if !opened_bracket
      opened_bracket = true
      name_dec = "$name_dec["
    end
    if add_coma
      name_dec = "$name_dec, "
    end
    if isa(ids, Range)
      dom = "$ids"
    else
      dom = "$(ids...)"
    end
    name_dec = "$name_dec$letter in $dom"
    add_coma = true
    letter_code += 0x01
  end
  return (name_dec, letter_code, opened_bracket, add_coma)
end

function submodel_create_vars_from_jumparray(parent, child, name, jumparray, bids, nbblockindices, bgmid, vardict)
  # Check if there is one variable or many variables
  var_id = ()
  var_str = "$name"
  length_bids = length(bids)
  letter_code = 0x61
  opened_bracket = false
  add_coma = false


  # Gets idcols of variables in the parent model
  parent_cols = Vector{Integer}()
  for index in keys(jumparray)
    (bid, bgid, cid) = get_bid_bgid_vcid(parent, index)
    if (fromIndexToMultiIndexArray(bgid) == bgmid)
      push!(parent_cols, jumparray.innerArray[index...].col)
    end
  end

  # Many block ids in the block group, we keep block id in the var name
  if length_bids > 1
    block_ids = [Vector{Any}() for i in 1:nbblockindices]
    for bid in bids
      for i in 1:nbblockindices
        push!(block_ids[i], bid[i])
      end
    end
    (var_str, letter_code, opened_bracket, add_coma) =
                 name_cont(var_str, bids, letter_code, opened_bracket, add_coma)
  end

  if nbblockindices + 1 >= length(jumparray.indexsets)
    ids = jumparray.indexsets[nbblockindices+1:end]
    (var_str, letter_code, opened_bracket, add_coma) =
                  name_cont(var_str, ids, letter_code, opened_bracket, add_coma)
  end

  if opened_bracket
    var_str = "$var_str]"
  end

  # Adding lower and upper bounds
  v = jumparray.innerArray[end]
  cat = getcategory(v)
  var_str = var_lb_ub(var_str, getlowerbound(v), getupperbound(v), cat)

  create_var = quote
    @variable($child, $(parse(var_str)), $cat)
  end
  eval(create_var)

  # Get idcols of variables in the child model
  child_cols = Vector{VarDescription}()
  if isa_jumparray(child.varDict[Symbol(name)])
    child_jumparray = child.varDict[Symbol(name)]
    for index in keys(child_jumparray)
      col = child_jumparray.innerArray[index...].col
      push!(child_cols, VarDescription(Symbol(name), index, col))
    end
  elseif isa_array(child.varDict[Symbol(name)])
    child_array = child.varDict[Symbol(name)]
    for (index, var) in enumerate(child_array)
      push!(child_cols, VarDescription(Symbol(name), (index,), var.col))
    end
  end

  (length(parent_cols) != length(child_cols)) && error("Cannot create the submodel.")
  for i in 1:length(parent_cols)
    push!(vardict, parent_cols[i] => child_cols[i])
  end
end

function submodel_create_cstrs_from_jumparray(parent, child, name, jumparray, bids, nbblockindices, bgmid, vardict)
  for index in keys(jumparray)
    (bid, bgid, cid) = get_bid_bgid_vcid(parent, index)
    if (fromIndexToMultiIndexArray(bgid) == bgmid)
      cstr_name = "$name[$(index...)]"

      cstr_ref = jumparray.innerArray[index...].idx
      cstr = parent.linconstr[cstr_ref]

      cstr_cont = ""
      for i in 1:length(cstr.terms.vars)
        if cstr.terms.coeffs[i] > 0
          cstr_cont = "$cstr_cont +"
        end

        parent_varcol = cstr.terms.vars[i].col
        (!haskey(vardict, parent_varcol)) && error("Cannot create")
        child_vardescription = vardict[parent_varcol]
        cstr_cont = "$cstr_cont $(cstr.terms.coeffs[i]) * $(child_vardescription.name)[$(child_vardescription.index...)]"
      end

      if cstr.ub != Inf
        cstr_cont = "$cstr_cont <= $(cstr.ub)"
      elseif cstr.lb != Inf
        cstr_cont = "$cstr_cont >= $(cstr.ub)"
      end

      create_cstr = quote
        @constraint($child, $(parse(cstr_name)), $(parse(cstr_cont)))
      end
      eval(create_cstr)
    end
  end
end
######################################################################


function show_m_var(parent::JuMP.Model)
  println("\e[44m parent.numCols =  $(parent.numCols) \e[00m")
  println("\e[44m parent.colLower = $(parent.colLower)\e[00m")
  println("\e[44m parent.colUpper = $(parent.colUpper)\e[00m")
  println("\e[44m parent.colCat = $(parent.colCat)\e[00m")
  println("\e[44m parent.colNames = $(parent.colNames)\e[00m")
  println("\e[44m parent.colNamesIJulia = $(parent.colNamesIJulia)\e[00m")
  println("\e[44m parent.varDict = $(parent.varDict)\e[00m")

  for x in parent.varDict
    println("\e[45m \t $(x.first) =>  & type = $(typeof(x.second)) \e[00m")
    println("\e[43m \t\t innerArray = $(x.second.innerArray)")
    println("\e[43m \t\t indexsets = $(x.second.indexsets)")
    println("\e[43m \t\t lookup = $(x.second.lookup)")
    println("\e[43m \t\t meta = $(x.second.meta) \e[00m")
  end
end

function show_m_cstr(parent::JuMP.Model)
  println("\e[44m parent.linconstr =  $(parent.linconstr) \e[00m")
  for x in parent.linconstr
    println("\e[45m \t $x & type = $(typeof(x)) \e[00m")
    println("\e[46m \t\t terms = $(x.terms) & type = $(typeof(x.terms)) \e[00m")
    println("\e[42m \t\t\t vars =  $(x.terms.vars) \e[00m")
    println("\e[42m \t\t\t coeffs =  $(x.terms.coeffs) \e[00m")
    println("\e[42m \t\t\t constant =  $(x.terms.constant) \e[00m")
    println("\e[46m \t\t lb = $(x.lb) \e[00m")
    println("\e[46m \t\t ub = $(x.ub) \e[00m")
  end

  println("\e[44m parent.conDict = $(parent.conDict)\e[00m")
  for x in parent.conDict
    println("\e[45m \t $(x.first) =>  & type = $(typeof(x.second)) \e[00m")
    println("\e[43m \t\t innerArray = $(x.second.innerArray)")
    println("\e[43m \t\t indexsets = $(x.second.indexsets)")
    println("\e[43m \t\t lookup = $(x.second.lookup)")
    println("\e[43m \t\t meta = $(x.second.meta) \e[00m")
  end
end
